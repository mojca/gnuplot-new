/* Hello, Emacs, this is -*-C-*-
 * $Id:$
 */

/* GNUPLOT - context.trm */

/*[
 * Copyleft 2006 Mojca Miklavec
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * AUTHORS:
 *   Mojca Miklavec
 *       <mojca.miklavec.lists at gmail.com>
 *     - author of this file
 *     - improvements to m-gnuplot.tex
 *     - mp-gnuplot.mp - metapost macros to support gnuplot-specifics
 *       inside ConTeXt
 *
 *   Hans Hagen (author of ConTeXt)
 *        <pragma at wxs.nl>
 *      - a lot of functionality added to ConTeXt to enable better support
 *        of Gnuplot module, many bugs fixed
 *      - author of the module m-gnuplot.tex to support inclusion of Gnuplot
 *        graphics into ConTeXt
 *      - constant support on the most tricky issues
 *   Taco Hoekwater (developer of Metapost & pdfTeX)
 *        <taco at elvenkind.com>
 *      - some code of this file, many tricks, lots of bug fixes,
 *        suggestions and testing
 *      - Hans's right hand in ConTeXt development:
 *        constant support on even more tricky issues
 *
 *   For questions, suggestions, comments, improvements please contact:
 *     - Mojca Miklavec <mojca.miklavec.lists at gmail.com> or
 *     - <gnuplot-context at googlegroups.com>
 *     - http://wiki.contextgarden.net/Gnuplot
 *
 * With special thanks to:
 * - Peter M\"unster for the initiative (Peter, sory for \")
 * - Renaud Aubin for maintaining the darcs repository
 * - Aditya Mahajan for some tricky parts in m-gnuplot.tex
 * - Timoth\'ee Lecomte for many suggestion about improving this terminal
 *
 */

/*
 * GNUPLOT -- context.trm
 *
 * This driver creates a ConTeXt document with embded metapost (metafun)
 * commands and is consequently used for creation of PDF documents.
 *
 * It is in a way similar to pslatex, but specialized for ConTeXt,
 * where it can also be used in the following way:
 *
 * \usemodule[gnuplot]
 *
 * \starttext
 * \section{Drawing nice graphs with \sc gnuplot}
 * \startGNUPLOTscript{sin}
 * pot sin(x)
 * \stopGNUPLOTscript
 * \useGNUPLOTgraphic[sin]
 * \stoptext
 *
 * For more information see http://wiki.contextgarden.net/Gnuplot
 *
 * Mostly based on:
 * - default settings copied from LaTeX terminal (because I liked it)
 * - path construction & drawing routines from MetaPost terminal
 * - advanced functionality with reference to PostScript terminal
 *
 * Future plans:
 * - add missing functionality:
 *   - improved support for palettes
 *   - support for binary images
 *   - smooth shading in color bars
 *   - other color spaces
 *   - gouraud shading (once implemented in 4.3)
 * - derive a better metapost terminal out of this one (to replace the old one)
 */

#include "driver.h"
#include "pm3d.h"

#ifdef TERM_REGISTER
register_term(context)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void CONTEXT_options __PROTO((void));
TERM_PUBLIC void CONTEXT_init __PROTO((void));
TERM_PUBLIC void CONTEXT_reset __PROTO((void));
TERM_PUBLIC void CONTEXT_text __PROTO((void));
TERM_PUBLIC void CONTEXT_graphics __PROTO((void));
TERM_PUBLIC void CONTEXT_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void CONTEXT_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void CONTEXT_linetype __PROTO((int lt));
TERM_PUBLIC void CONTEXT_put_text __PROTO((unsigned int x, unsigned int y, const char *str));

TERM_PUBLIC  int CONTEXT_text_angle __PROTO((int ang));
TERM_PUBLIC  int CONTEXT_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC void CONTEXT_point __PROTO((unsigned int x, unsigned int y, int number));
TERM_PUBLIC void CONTEXT_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head));
TERM_PUBLIC  int CONTEXT_set_font __PROTO((const char *font)); /* "font,size" */
TERM_PUBLIC void CONTEXT_pointsize __PROTO((double pointsize));
TERM_PUBLIC void CONTEXT_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
TERM_PUBLIC void CONTEXT_fill __PROTO((int style));
TERM_PUBLIC void CONTEXT_linewidth __PROTO((double linewidth));
TERM_PUBLIC  int CONTEXT_make_palette __PROTO((t_sm_palette *palette));
/* TERM_PUBLIC void CONTEXT_previous_palette __PROTO((void)); do we need it? */
TERM_PUBLIC void CONTEXT_set_color __PROTO((t_colorspec *colorspec));
TERM_PUBLIC void CONTEXT_filled_polygon __PROTO((int points, gpiPoint *corners));
#ifdef WITH_IMAGE
/* TERM_PUBLIC void CONTEXT_image __PROTO((unsigned, unsigned, coordval *, gpiPoint *, t_imagecolor)); TODO */
#endif /* WITH_IMAGE */

/* Metapost can only deal with numbers between 2^{-16} and 2^12=4069 */
/* the values will be set later */
/* scale is 1pt = 100 units */

#define CONTEXT_DPI (2400)
/* default plot size will be 5in x 3in*/
#define CONTEXT_XSIZE_VALUE 5
#define CONTEXT_YSIZE_VALUE 3
#define CONTEXT_XSIZE_UNIT UNIT_IN
#define CONTEXT_YSIZE_UNIT UNIT_IN
#define CONTEXT_XMAX (CONTEXT_XSIZE_VALUE*CONTEXT_DPI)
#define CONTEXT_YMAX (CONTEXT_YSIZE_VALUE*CONTEXT_DPI)
/* default fontsize: 12pt */
#define CONTEXT_FONTSIZE 12.0
/* default height of char: 12pt by default */
#define CONTEXT_VCHAR (CONTEXT_DPI*CONTEXT_FONTSIZE/72.27)
/* in ConTeXt 12pt LM font is the default;
 * at that size digits are 5.8749847pt wide
 * in LaTeX, which assumes 11pt, the ratio is 5.3/11, which is similar */
#define CONTEXT_LM_H_TO_V_RATIO 0.4895
#define CONTEXT_HCHAR (CONTEXT_LM_H_TO_V_RATIO*CONTEXT_VCHAR)
/* default tic size: 3.5bp (chosen to suit the size of plot approximately)
 * - in LaTeXt it's 5bp
 * - in PostScript it's 3.15pt;
 */
#define CONTEXT_HTIC (3.5*CONTEXT_DPI/72)
#define CONTEXT_VTIC CONTEXT_HTIC

#endif /* TERM_PROTO */


#ifndef TERM_PROTO_ONLY
#ifdef TERM_BODY

/*********
 * UNITS *
 *********
 *
 * This part of code is meant for parsing the units in
 *     set term context size 5in,3in
 * or even
 *     set term context size (5+3/2) cm, 8-2**2in
 * which will make the picture 6.5 centimeters wide and 4 inches high.
 *
 * It is also used for (rather dirty) parsing of font sizes,
 * which is needed for estimating character width & height.
 *
 * This code may be taken out of the terminal if anyone needs it.
 *
 * Similar functionality is provided for some drivers (such as PostScript),
 * to parse terminal size, but is more limited and supports less units.
 */

typedef enum size_unit {
	UNIT_PT, /* point                          */
	UNIT_PC, /* pica:        1pc = 12pt        */
	UNIT_IN, /* inch:        1in = 72.27pt     */
	UNIT_BP, /* big point:   72bp = 1in        */
	UNIT_CM, /* centimeter:  2.54cm = 1in      */
	UNIT_MM, /* millimeter:  10mm = 1cm        */
	UNIT_DD, /* didot point: 1157dd = 1238pt   */
	UNIT_CC, /* cicero:      1cc = 12dd        */
	/* ----- // --- [not absolute units]       */
	UNIT_PX, /* pixel:        [dpi resolution] * 1px = 1in */
	UNIT_RELATIVE, /* relative: no specific unit           */
	UNIT_OTHER
} size_unit;

static struct gen_table units[] = {
	{ "pt",    UNIT_PT }, /* point       */
	{ "pc",    UNIT_PC }, /* pica        */
	{ "in$ch", UNIT_IN }, /* inch        */
	{ "bp",    UNIT_BP }, /* big point   */
	{ "cm",    UNIT_CM }, /* centimeter  */
	{ "mm",    UNIT_MM }, /* millimeter  */
	{ "dd",    UNIT_DD }, /* didot point */
	{ "cc",    UNIT_CC }, /* cicero      */
	{ "px",    UNIT_PX }, /* pixel       */
	{ NULL,    UNIT_OTHER }
};

typedef struct dimension_t {
    float value;
    size_unit unit;
} dimension_t;

static double convert_to_unit __PROTO((dimension_t from, size_unit to_unit));
static char*  unit_name __PROTO((size_unit unit));
/* needs a better name; lookup_table should be OK for it, but only if unit is a token,
 * otherwise the work has to be done "manually" */
static size_unit string_to_unit __PROTO((char *unit_name));

/* --------------
 * string_to_unit
 * --------------
 *
 * Returns two-letter name for the unit
 * (it can be used in TeX or metapost directly)
 */
static char*
unit_name(size_unit unit)
{
	switch(unit) {
		case UNIT_PT: return "pt";
		case UNIT_PC: return "pc";
		case UNIT_IN: return "in";
		case UNIT_BP: return "bp";
		case UNIT_CM: return "cm";
		case UNIT_MM: return "mm";
		case UNIT_DD: return "dd";
		case UNIT_CC: return "cc";
		case UNIT_PX: return "px";
		default: return NULL; /* XXX: do we need some error handling here? */
	}
}

/* --------------
 * string_to_unit
 * --------------
 *
 * Accepts a two-letter name for an unit
 * and returns the unit type
 */
static size_unit
string_to_unit(char *name)
{
	/* invalid unit for no string or for a string of any other size than two */
	if (name == NULL) return UNIT_OTHER;
	if (strlen(name) != 2) return UNIT_OTHER;

	switch (name[0]) {
		case 'b':
			if (name[1] == 'p') return UNIT_BP;
		case 'c':
			if (name[1] == 'c') return UNIT_CC;
			if (name[1] == 'm') return UNIT_CM;
		case 'd':
			if (name[1] == 'd') return UNIT_DD;
		case 'i':
			if (name[1] == 'n') return UNIT_IN;
		case 'm':
			if (name[1] == 'm') return UNIT_MM;
		case 'p':
			if (name[1] == 'c') return UNIT_PC;
			if (name[1] == 't') return UNIT_PT;
			if (name[1] == 'x') return UNIT_PX;
		default:
			return UNIT_OTHER;
	}
}

/* ---------------
 * convert_to_unit
 * ---------------
 *
 * Converts the value (from.value) from one unit (from.unit)
 * to another (to_unit).
 *
 * This "stupid" converter should be rewritten completely for better efficiency,
 * although it currently works OK. It should be initilized only once.
 */
static double
convert_to_unit(dimension_t from, size_unit to_unit)
{
	/* conversion is done via inches
	 * conversion[UNIT_CM] returns how much inches is one cm (ie. 1/2.54) */
	double conversion[20]; /* XXX: shoud be sizeof(size_unit) */

	if(from.unit == to_unit) {
		return (double)from.value;
	/* XXX: this is wrong, but I have no other idea what to do with it.
	        It's not yet used anywhere so far, so let's care about it
	        when the need arises. */
	} else if(to_unit == UNIT_RELATIVE || to_unit == UNIT_OTHER) {
		return (double)from.value;
	}

	conversion[UNIT_PT] = 1.0/72.27;
	conversion[UNIT_PC] = 12.0*conversion[UNIT_PT];
	conversion[UNIT_IN] = 1.0;
	conversion[UNIT_BP] = 1.0/72.0;
	conversion[UNIT_CM] = 1.0/2.54;
	conversion[UNIT_MM] = conversion[UNIT_CM]/10.0;
	conversion[UNIT_DD] = 1238.0/1157.0*conversion[UNIT_PT];
	conversion[UNIT_CC] = 12.0*conversion[UNIT_DD];
	/* for pixel some resolution would be needed */
	conversion[UNIT_PX] = 1/72.0; /* XXX: wrong! (but not used anywhere yet) */

	return from.value*conversion[from.unit]/conversion[to_unit];
}

/****************
 * End of UNITS *
 ****************/

static void CONTEXT_params_reset __PROTO((void));

static void CONTEXT_adjust_dimensions __PROTO((void));
static void CONTEXT_fontstring_parse __PROTO((char *from_string, char *to_string, int to_size, dimension_t *dimension));

static void CONTEXT_startpath __PROTO((void));
static void CONTEXT_endpath __PROTO((void));

static void CONTEXT_write_palette __PROTO((t_sm_palette *palette));
static void CONTEXT_write_palette_gradient __PROTO((gradient_struct *gradient, int cnt));


/* Each number is divided by 100 (1/100th of a point is drawn) */

static int CONTEXT_posx;
static int CONTEXT_posy;
/* remembers where we started the path:
 * if we finish it in the same point, the path is closed with --cycle
 * 
 * After I impplemented this, the functionality has been added to gnuplot core
 * and PostScript terminal uses it, but to be on the safe side,
 * I prefer not to add last-minute patches which could potentially break something.
 * (the code written here proved to be rather safe & working so far)
 * In the next version the core functionality should be integrated & tested.
 */
static int CONTEXT_path_start_x;
static int CONTEXT_path_start_y;
/* fontname, fontsize */
static char CONTEXT_font[MAX_ID_LEN+1] = "";
static dimension_t CONTEXT_fontsize = {CONTEXT_FONTSIZE, UNIT_PT};

/* fontname,fontsize to be put next to font labels if needed */
static char CONTEXT_font_explicit[2*MAX_ID_LEN+1] = "";
/* this is only set to >0 if asked for explicitely (for example with set_font(",15pt")) */
static dimension_t CONTEXT_fontsize_explicit = {0, UNIT_PT};

/* the last pointsize used (it will only be changed if it becomes different) */
static double CONTEXT_old_pointsize = 1.0;
/* the last linewidth used (it will only be changed if it becomes different) */
static double CONTEXT_old_linewidth = 1.0;
/* the last linetype used (it will only be changed if it becomes different) */
static int CONTEXT_old_linetype = -3;
/* was the color changed explicitly? */
static TBOOLEAN CONTEXT_color_changed = FALSE;

/* counts the number of graphics */
static int CONTEXT_counter = 0;

/* the number of path nodes before a newline (doesn't really matter,
 * could be set to 1000; check if any editors have problems with that) */
#define CONTEXT_LINEMAX 4

/* if we're inside a path (unfinished line) then path_count > 0
 * (PDF has PDF_pathIsOpen) */
static unsigned int CONTEXT_path_count = 0;
/* this true/false switch is used to help distinguish dots from paths */
static unsigned int CONTEXT_path_is_dot = 0;

/* angle of text rotation */
static int CONTEXT_ang = 0;
/* left/middle/right text justification */
static enum JUSTIFY CONTEXT_justify = LEFT;

enum LINEJOIN { LINEJOIN_MITER, LINEJOIN_ROUND, LINEJOIN_BEVEL };
enum LINECAP  { LINECAP_BUTT, LINECAP_ROUND, LINECAP_SQUARE };

/* Pallete has to be stored for the usage in later plots */
static t_sm_palette *CONTEXT_old_palette;

/*********************/
/* global parameters */
/*********************/

/* btex ... etex is hopefully not needed any more (and not supported either)
 * it may be removed, but it was left here for historical reasons
 * and if I decide to extend this terminal to support plain metapost,
 * it will be needed again.
 *
 * textext("...") is not needed and supported any more either,
 * but was left here for historical reasons & (hidden) testing purposes
 * It will be removed.
 *
 * At the beginning textext("...") has been used, but:
 * - it was extremely inefficient
 * - it caused only troubles (different settings etc.)
 * Because of the second, btex ... etex has been provided as a slightly
 * more reliable alternative. The first one hasn't been solved until
 * a new command for text placement showed up.
 *
 * After Hans Hagen has patched it, he implemented a new command \sometxt{...},
 * which was one of the most crucial steps towards usability of this terminal.
 * Without it the terminal was close-to-useless because of unbearably slow speed.
 *
 * See also "\sometxt" MyWay on contextgarden.net about that.
 * Hans & Taco: thanks a lot for this wonderful macro!!!
 */
enum CONTEXT_TEXT   { CONTEXT_TEXT_TEXTEXT, CONTEXT_TEXT_SOMETXT, CONTEXT_TEXT_BTEX };
/* whether points are drawn with metapost or typeset with TeX (easy configurable) */
enum CONTEXT_POINTS { CONTEXT_POINTS_WITH_METAPOST, CONTEXT_POINTS_WITH_TEX };

typedef struct CONTEXT_params_t {
	dimension_t         xsize;               /* 5in   */
	dimension_t         ysize;               /* 3in   */
	TBOOLEAN            standalone;          /* false */
	char               *header;              /* ""    */
	TBOOLEAN            color;               /* true  */
	TBOOLEAN            dashed;              /* true  */
	enum LINEJOIN       linejoin;            /* MITER */
	enum LINECAP        linecap;             /* BUTT  */
	float               scale_dashlength;    /* 1.0   */
	float               scale_linewidth;     /* 1.0   */
	float               scale_text;          /* 1.0   */
	enum CONTEXT_TEXT   text;                /* CONTEXT_TEXT_SOMETXT */
	enum CONTEXT_POINTS points;              /* CONTEXT_POINTS_WITH_METAPOST */
	char                font[MAX_ID_LEN+1];  /* ""    */
	dimension_t         fontsize;            /* 12pt  */
} CONTEXT_params_t;


#define CONTEXT_PARAMS_DEFAULT { \
	{CONTEXT_XSIZE_VALUE, CONTEXT_XSIZE_UNIT},\
	{CONTEXT_YSIZE_VALUE, CONTEXT_YSIZE_UNIT},\
	FALSE,\
	NULL,\
	TRUE,\
	TRUE,\
	LINEJOIN_MITER,\
	LINECAP_BUTT,\
	1.0,\
	1.0,\
	1.0,\
	CONTEXT_TEXT_SOMETXT,\
	CONTEXT_POINTS_WITH_METAPOST,\
	"",\
	{CONTEXT_FONTSIZE, UNIT_PT}\
}

static CONTEXT_params_t CONTEXT_params = CONTEXT_PARAMS_DEFAULT;

enum CONTEXT_id {
	CONTEXT_OPT_DEFAULT,
	CONTEXT_OPT_SIZE,
	CONTEXT_OPT_SIZE_DEFAULT,
	CONTEXT_OPT_INPUT, CONTEXT_OPT_STANDALONE,
	CONTEXT_OPT_HEADER, CONTEXT_OPT_NOHEADER,
	CONTEXT_OPT_COLOR, CONTEXT_OPT_MONOCHROME,
	CONTEXT_OPT_DASHED, CONTEXT_OPT_SOLID,
	CONTEXT_OPT_LINEJOIN_MITERED, CONTEXT_OPT_LINEJOIN_ROUNDED, CONTEXT_OPT_LINEJOIN_BEVELED,
	CONTEXT_OPT_LINECAP_BUTT, CONTEXT_OPT_LINECAP_ROUNDED, CONTEXT_OPT_LINECAP_SQUARED,
	CONTEXT_OPT_SCALE_DASHLENGTH, CONTEXT_OPT_SCALE_LINEWIDTH, CONTEXT_OPT_SCALE_TEXT,
	CONTEXT_OPT_TEXT_SOMETXT, CONTEXT_OPT_TEXT_TEXTEXT,
	CONTEXT_OPT_POINTS_WITH_METAPOST, CONTEXT_OPT_POINTS_WITH_TEX,
	CONTEXT_OPT_DEFAULTFONT,
	CONTEXT_OPT_FONT,
	CONTEXT_OPT_OTHER
};
static struct gen_table CONTEXT_opts[] = {
	{ "d$efault", CONTEXT_OPT_DEFAULT },
	{ "size", CONTEXT_OPT_SIZE },
	{ "defaultsize", CONTEXT_OPT_SIZE_DEFAULT },
	{ "inp$ut", CONTEXT_OPT_INPUT },
	{ "stand$alone", CONTEXT_OPT_STANDALONE },
	{ "header", CONTEXT_OPT_HEADER },
	{ "noheader", CONTEXT_OPT_NOHEADER },
	{ "col$or", CONTEXT_OPT_COLOR },
	{ "col$our", CONTEXT_OPT_COLOR },
	{ "mono$chrome", CONTEXT_OPT_MONOCHROME },
	{ "da$shed", CONTEXT_OPT_DASHED },
	{ "so$lid", CONTEXT_OPT_SOLID },
	{ "miter$ed", CONTEXT_OPT_LINEJOIN_MITERED },
	{ "rounded", CONTEXT_OPT_LINEJOIN_ROUNDED },
	{ "bevel$ed", CONTEXT_OPT_LINEJOIN_BEVELED },
	{ "butt", CONTEXT_OPT_LINECAP_BUTT },
	{ "round", CONTEXT_OPT_LINECAP_ROUNDED },
	{ "square$d", CONTEXT_OPT_LINECAP_SQUARED },
	{ "dashl$ength", CONTEXT_OPT_SCALE_DASHLENGTH },
	{ "dl", CONTEXT_OPT_SCALE_DASHLENGTH },
	{ "linew$idth", CONTEXT_OPT_SCALE_LINEWIDTH },
	{ "lw", CONTEXT_OPT_SCALE_LINEWIDTH },
	{ "textscale", CONTEXT_OPT_SCALE_TEXT },
	{ "textext", CONTEXT_OPT_TEXT_TEXTEXT },
	{ "sometxt", CONTEXT_OPT_TEXT_SOMETXT },
	{ "pointswithmp", CONTEXT_OPT_POINTS_WITH_METAPOST},
	{ "pointswithmetapost", CONTEXT_OPT_POINTS_WITH_METAPOST},
	{ "pointswithtex", CONTEXT_OPT_POINTS_WITH_TEX},
	{ "font", CONTEXT_OPT_FONT },
	{ "defaultfont", CONTEXT_OPT_DEFAULTFONT },
	{ NULL, CONTEXT_OPT_OTHER }
};

/* ****************
 * CONTEXT_options*
 * ****************
 *
 * The routine resets all the parameters of the terminal to their default
 * value; the routine should be better implemented if it would use the values
 * from "#define CONTEXT_PARAMS_DEFAULT", but I don't know how to do this;
 * There must be a cleaner way, I'm sure. I double-checked that the values here
 * and there agree with each other.
 */
static void
CONTEXT_params_reset()
{
	/* default size is 5x3 inches */
	CONTEXT_params.xsize.value      = CONTEXT_XSIZE_VALUE;
	CONTEXT_params.ysize.value      = CONTEXT_YSIZE_VALUE;
	CONTEXT_params.xsize.unit       = CONTEXT_XSIZE_UNIT;
	CONTEXT_params.ysize.unit       = CONTEXT_YSIZE_UNIT;

	CONTEXT_params.standalone       = FALSE;
	if (CONTEXT_params.header) {
		free(CONTEXT_params.header);
		CONTEXT_params.header = NULL;
	}
	CONTEXT_params.color            = TRUE;
	CONTEXT_params.dashed           = TRUE;
	CONTEXT_params.linejoin         = LINEJOIN_MITER;
	CONTEXT_params.linecap          = LINECAP_BUTT;
	CONTEXT_params.scale_dashlength = 1.0;
	CONTEXT_params.scale_linewidth  = 1.0;
	CONTEXT_params.scale_text       = 1.0;
	CONTEXT_params.text             = CONTEXT_TEXT_SOMETXT;
	CONTEXT_params.points           = CONTEXT_POINTS_WITH_METAPOST;
	CONTEXT_params.font[0]          = 0;
	CONTEXT_params.fontsize.value   = CONTEXT_FONTSIZE;
	CONTEXT_params.fontsize.unit    = UNIT_PT;
}


/* ****************
 * CONTEXT_options*
 * ****************
 *
 * Parses "set term context [options]".
 */
TERM_PUBLIC void
CONTEXT_options()
{
	int    i;
	struct value a;
	char   *tmp_string;
	char   tmp_font[MAX_ID_LEN+1] = "";
	char   tmp_term_options[MAX_LINE_LEN+1] = "";

	enum  size_unit tmp_unit[2];
	float tmp_float[2];
	dimension_t tmp_dimension;

	while (!END_OF_COMMAND) {
		switch (lookup_table(&CONTEXT_opts[0], c_token)) {
		case CONTEXT_OPT_DEFAULT:
			c_token++;
			/* there should be a better way to do it, but I don't know how */
			CONTEXT_params_reset();
			break;
		/*---------------------------------------------------*/
		case CONTEXT_OPT_SIZE:
			c_token++;
			/* size <xsize> {cm|in}, <ysize> {cm|in}
			 *
			 * value of the xsize
			 * XXX: perhaps the values shouldn't be saved right away
			 * just take care that all the values supported here are supported in conversion and
			 * in output routine as well
			 */
			for (i=0; i<2; i++) {
				tmp_float[i] = real(const_express(&a));
				/* check if the size is positive (minimal requirement) */
				if (tmp_float[i] <= 0)
					int_error(c_token-1,"Size has to be positive.");
				/* if unit (inch or cm) is used, use that one, otherwise interpret that value
				 * as if it was a relative to the default value (5in); ie: 1.5 means 7.5 inches */
				switch (lookup_table(&units[0], c_token)) {
					case UNIT_IN:
					case UNIT_CM:
					case UNIT_MM:
						tmp_unit[i] = lookup_table(&units[0], c_token);
						c_token++;
						/* read the comma after the first number */
						if (i==0) {
							if (equals(c_token, ",")) {
								c_token++;
							} else {
								int_error(c_token,"',' expected.\nSize has to be specified as\n\tsize <xsize> {in|cm}, <ysize> {in|cm}\nor as\n\tsize <relative to default>");
							}
						}
						break;
					case UNIT_PT:
					case UNIT_PC:
					case UNIT_BP:
					case UNIT_DD:
					case UNIT_CC:
						int_error(c_token,"Sorry, this unit is not supported. Use cm or in.");
						break;
					case UNIT_PX:
						int_error(c_token,"Size for this terminal cannot be specified in pixels. Use cm or in.");
						break;
					/* if comma follows, interpret as relative unit
					 * if some other unit follows */
					default:
						/* first run: if no unit is specified, we expect at least a comma */
						if (i==0) {
							if (equals(c_token, ",")) {
								c_token++;
								/* default xsize is 5in - use the current size as relative value */
								tmp_float[0] *= CONTEXT_XSIZE_VALUE;
								tmp_unit[0]   = CONTEXT_XSIZE_UNIT;
							} else {
								tmp_float[1] = tmp_float[0]*CONTEXT_YSIZE_VALUE;
								tmp_float[0] = tmp_float[0]*CONTEXT_XSIZE_VALUE;
								tmp_unit[0]  = CONTEXT_XSIZE_UNIT;
								tmp_unit[1]  = CONTEXT_YSIZE_UNIT;
								i++;
							}
						/* second run: if no unit is specified, proceed to next command
						 * and interpret the expression as being relative to the default size */
						} else {
							tmp_float[1] *= CONTEXT_YSIZE_VALUE;
							tmp_unit[1]   = CONTEXT_YSIZE_UNIT;
						}
						break;
				}
			}
			CONTEXT_params.xsize.value = tmp_float[0];
			CONTEXT_params.ysize.value = tmp_float[1];
			CONTEXT_params.xsize.unit  = tmp_unit[0];
			CONTEXT_params.ysize.unit  = tmp_unit[1];
			break;
		/*---------------------------------------------------*/
		case CONTEXT_OPT_SIZE_DEFAULT:
			c_token++;
			CONTEXT_params.xsize.value = CONTEXT_XSIZE_VALUE;
			CONTEXT_params.ysize.value = CONTEXT_YSIZE_VALUE;
			CONTEXT_params.xsize.unit  = CONTEXT_XSIZE_UNIT;
			CONTEXT_params.ysize.unit  = CONTEXT_YSIZE_UNIT;
			break;
		case CONTEXT_OPT_INPUT:
			c_token++;
			CONTEXT_params.standalone = FALSE;
			break;
		case CONTEXT_OPT_STANDALONE:
			c_token++;
			CONTEXT_params.standalone = TRUE;
			break;

		case CONTEXT_OPT_HEADER:
			c_token++;
			/* parse the string */
			tmp_string = try_to_get_string();
			if (!tmp_string) {
				int_error(c_token,"String containing header information expected");
			/* only touch the options if the string is OK */
			} else {
				/* remove the old header if any */
				if (CONTEXT_params.header) {
					free(CONTEXT_params.header);
					CONTEXT_params.header = NULL;
				}
				/* and set the new one if nonempty;
				 * empty header will be treated as 'noheader' */
				if (strlen(tmp_string) > 0) {
					CONTEXT_params.header = tmp_string;
				} else {
					free(tmp_string);
				}
			}
			break;
		case CONTEXT_OPT_NOHEADER:
			c_token++;
			/* delete the header if it exists */
			if (CONTEXT_params.header) {
				free(CONTEXT_params.header);
				CONTEXT_params.header = NULL;
			}
			break;
		case CONTEXT_OPT_COLOR:
			c_token++;
			CONTEXT_params.color = TRUE;
			/* just mimick other terminals; no idea what it does;
			   at the moment monochrome is not fully implemented either */
			term->flags &= ~TERM_MONOCHROME;
			break;
		case CONTEXT_OPT_MONOCHROME:
			c_token++;
			CONTEXT_params.color = FALSE;
			term->flags |= TERM_MONOCHROME;
			break;
		case CONTEXT_OPT_DASHED:
			c_token++;
			CONTEXT_params.dashed = TRUE;
			break;
		case CONTEXT_OPT_SOLID:
			c_token++;
			CONTEXT_params.dashed = FALSE;
			break;
		case CONTEXT_OPT_LINEJOIN_MITERED:
			c_token++;
			CONTEXT_params.linejoin = LINEJOIN_MITER;
			break;
		case CONTEXT_OPT_LINEJOIN_ROUNDED:
			c_token++;
			CONTEXT_params.linejoin = LINEJOIN_ROUND;
			break;
		case CONTEXT_OPT_LINEJOIN_BEVELED:
			c_token++;
			CONTEXT_params.linejoin = LINEJOIN_BEVEL;
			break;
		case CONTEXT_OPT_LINECAP_BUTT:
			c_token++;
			CONTEXT_params.linecap = LINECAP_BUTT;
			break;
		case CONTEXT_OPT_LINECAP_ROUNDED:
			c_token++;
			CONTEXT_params.linecap = LINECAP_ROUND;
			break;
		case CONTEXT_OPT_LINECAP_SQUARED:
			c_token++;
			CONTEXT_params.linecap = LINECAP_SQUARE;
			break;
		case CONTEXT_OPT_SCALE_DASHLENGTH:
			c_token++;
			CONTEXT_params.scale_dashlength = real(const_express(&a));
			break;
		case CONTEXT_OPT_SCALE_LINEWIDTH:
			c_token++;
			CONTEXT_params.scale_linewidth = real(const_express(&a));
			break;
		case CONTEXT_OPT_SCALE_TEXT:
			c_token++;
			CONTEXT_params.scale_text = real(const_express(&a));
			break;
		case CONTEXT_OPT_DEFAULTFONT:
			c_token++;
			/* CONTEXT_params.font should be an empty string */
			CONTEXT_params.font[0] = 0;
			/* default fontsize is 12pt */
			CONTEXT_params.fontsize.value = CONTEXT_FONTSIZE;
			CONTEXT_params.fontsize.unit = UNIT_PT;
			break;
		/* since the other two options are disabled, it makes no sense any more - will disappear */
		case CONTEXT_OPT_TEXT_SOMETXT:
			c_token++;
			CONTEXT_params.text = CONTEXT_TEXT_SOMETXT;
			break;
		/* not supported by metapost macros any more - will disappear */
		case CONTEXT_OPT_TEXT_TEXTEXT:
			c_token++;
			/* CONTEXT_params.text = CONTEXT_TEXT_TEXTEXT; */
			int_warn(c_token,"textext is now deprecated: sometxt will be used instead!");
			break;
/*
 * so old and deprecated that we don't want users
 * to complain about its inefficiency
 *
 * but if this terminal is going to support plain metapost in the future,
 * we'll need it again
 *
		case CONTEXT_OPT_BTEX:
			c_token++;
			CONTEXT_params.text = CONTEXT_TEXT_BTEX;
			break;
*/
		case CONTEXT_OPT_POINTS_WITH_METAPOST:
			c_token++;
			CONTEXT_params.points = CONTEXT_POINTS_WITH_METAPOST;
			break;
		case CONTEXT_OPT_POINTS_WITH_TEX:
			c_token++;
			CONTEXT_params.points = CONTEXT_POINTS_WITH_TEX;
			break;
		/*
		 * The preferred way to set the font is to set it in a document itself,
		 * labels in gnuplot in graphs will then inherit that font.
		 *
		 * However, it is polite to tell gnuplot which size is going to be used,
		 * so that it can estimate size of text labels.
		 *
		 * Whenever you specify
		 *     set term context font "fontname,14pt" (or "fontname,14")
		 *
		 * there are two possibilities:
		 * - if STANDALONE mode is on, then the whole string will be used as
		 *   \setupbodyfont[fontname,14pt]
		 *   somewhere on top of the document (you still have to make sure that you
		 *   included the proper typescript, so that "fontname" will be recognised
		 * - in the other case (INPUT mode) only the font size will be used
		 *   internally to estimate sizes of labels, but the font name
		 *   won't be written anywhere
		 */
		case CONTEXT_OPT_FONT:
			c_token++;
			if ((tmp_string = try_to_get_string())) {
				/* if string with font name (and size) has been provided, parse it,
				 * otherwise expect font size (as an integer {+units}) */
				if (tmp_string) {
					/*
					 * copies font name from tmp_string to tmp_font,
					 * but leaves out font size and saves it to tmp_dimension instead
					 *
					 * if no font size is specified, then tmp_dimension.value is set to 0
					 */
					CONTEXT_fontstring_parse(tmp_string, tmp_font, sizeof(tmp_font), &tmp_dimension);
					/* copies font name to parameters */
					strncpy(CONTEXT_params.font, tmp_font, sizeof(CONTEXT_params.font));
					/* free allocated memmory */
					free(tmp_string);

					/* (TODO: this code repeats three times!!!)
					 * save font size:
					 *
					 * - if size > 0, copy
					 * - if size < 0, fix the size to default value (12pt)
					 * - if size = 0, ignore
					 */
					if (tmp_dimension.value > 0 && tmp_dimension.unit != UNIT_OTHER) {
						CONTEXT_params.fontsize.value = tmp_dimension.value;
						CONTEXT_params.fontsize.unit  = tmp_dimension.unit;
					} else if (tmp_dimension.value < 0 || tmp_dimension.unit == UNIT_OTHER) {
						CONTEXT_params.fontsize.value = CONTEXT_FONTSIZE;
						CONTEXT_params.fontsize.unit  = UNIT_PT;
					}
					/* optional font size at the end */
					/*
					 * XXX: this code repeats twice, which is a bad programming habit!
					 *      (plese be polite and provide a function instead)
					 */
					if (isanumber(c_token)) {
						/* fontsize */
						tmp_dimension.value = real(const_express(&a));
						tmp_dimension.unit  = UNIT_PT;
						/* optional dimension of font size */
						switch (lookup_table(&units[0], c_token)) {
							case UNIT_IN:
							case UNIT_CM:
							case UNIT_MM:
							case UNIT_PT:
							case UNIT_PC:
							case UNIT_BP:
							case UNIT_DD:
							case UNIT_CC:
								tmp_dimension.unit = lookup_table(&units[0], c_token);
								c_token++;
								break;
							case UNIT_PX:
								int_error(c_token,"Fontsize cannot be specified in pixels. Use other unit or leave dimension out.");
								break;
							default:
								/* apparently no unit has been specified */
								break;
						}
					}
					/*
					 * save font size:
					 *
					 * - if size > 0, copy
					 * - if size < 0, fix the size to default value (12pt)
					 * - if size = 0, ignore
					 */
					if (tmp_dimension.value > 0 && tmp_dimension.unit != UNIT_OTHER) {
						CONTEXT_params.fontsize.value = tmp_dimension.value;
						CONTEXT_params.fontsize.unit  = tmp_dimension.unit;
					} else if (tmp_dimension.value < 0 || tmp_dimension.unit == UNIT_OTHER) {
						CONTEXT_params.fontsize.value = CONTEXT_FONTSIZE;
						CONTEXT_params.fontsize.unit  = UNIT_PT;
					}
				}
			/* font size (and possibly dimension) */
			} else {
				/* used to be:
				 * int_error(c_token,"String containing font name and/or size expected");
				 */
				/* fontsize */
				tmp_dimension.value = real(const_express(&a));
				tmp_dimension.unit  = UNIT_PT;
				/* optional dimension of font size */
				switch (lookup_table(&units[0], c_token)) {
					case UNIT_IN:
					case UNIT_CM:
					case UNIT_MM:
					case UNIT_PT:
					case UNIT_PC:
					case UNIT_BP:
					case UNIT_DD:
					case UNIT_CC:
						tmp_dimension.unit = lookup_table(&units[0], c_token);
						c_token++;
						break;
					case UNIT_PX:
						int_error(c_token,"Fontsize cannot be specified in pixels. Use other unit or leave dimension out.");
						break;
					default:
						/* apparently no unit has been specified */
						break;
				}
				/*
				 * save font size (same as above):
				 *
				 * - if size > 0, copy
				 * - if size < 0, fix the size to default value (12pt)
				 * - if size = 0, ignore
				 */
				if (tmp_dimension.value > 0) {
					CONTEXT_params.fontsize.value = tmp_dimension.value;
					CONTEXT_params.fontsize.unit  = tmp_dimension.unit;
				} else if (tmp_dimension.value < 0) {
					CONTEXT_params.fontsize.value = CONTEXT_FONTSIZE;
					CONTEXT_params.fontsize.unit  = UNIT_PT;
				}
			}
			break;
		case CONTEXT_OPT_OTHER:
		default:
			/* error */
				int_error(c_token, "extraneous argument in set terminal %s",term->name);
			break;
		}
	}

	/* current font size in pt (to be used in CONTEXT_adjust_dimensions) */
	CONTEXT_fontsize.value = CONTEXT_params.fontsize.value;
	CONTEXT_fontsize.unit  = CONTEXT_params.fontsize.unit;

	/* sets term->xmax, ymax, vchar, hchar */
	CONTEXT_adjust_dimensions();

	snprintf(term_options, sizeof(term_options),
			"size %g%s,%g%s %s %s",
			CONTEXT_params.xsize.value,
			unit_name(CONTEXT_params.xsize.unit),
			CONTEXT_params.ysize.value,
			unit_name(CONTEXT_params.ysize.unit),
			CONTEXT_params.standalone ? "standalone" : "input",
			CONTEXT_params.header == NULL ? "noheader \\\n   " : "\\\n   header ");

	if (CONTEXT_params.header != NULL) {
		strncat(term_options,"\"",                  sizeof(term_options)-strlen(term_options));
		strncat(term_options,CONTEXT_params.header, sizeof(term_options)-strlen(term_options));
		strncat(term_options,"\" \\\n   ",          sizeof(term_options)-strlen(term_options));
	}

	strncat(term_options,
		CONTEXT_params.color ? "color " : "monochrome ",
		sizeof(term_options)-strlen(term_options));

	switch(CONTEXT_params.linejoin) {
		case LINEJOIN_MITER:
			strncat(term_options, "mitered ",
				sizeof(term_options)-strlen(term_options)); break;
		case LINEJOIN_ROUND:
			strncat(term_options, "rounded ",
				sizeof(term_options)-strlen(term_options)); break;
		case LINEJOIN_BEVEL:
			strncat(term_options, "beveled ",
				sizeof(term_options)-strlen(term_options)); break;
	}
	switch(CONTEXT_params.linecap) {
		case LINECAP_BUTT  :
			strncat(term_options, "butt",
				sizeof(term_options)-strlen(term_options)); break;
		case LINECAP_ROUND :
			strncat(term_options, "round",
				sizeof(term_options)-strlen(term_options)); break;
		case LINECAP_SQUARE:
			strncat(term_options, "squared",
				sizeof(term_options)-strlen(term_options)); break;
	}

	snprintf(tmp_term_options, sizeof(tmp_term_options),
		" %s dashlength %g linewidth %g textscale %g \\\n   ",
		CONTEXT_params.dashed ? "dashed" : "solid",
		CONTEXT_params.scale_dashlength,
		CONTEXT_params.scale_linewidth,
		CONTEXT_params.scale_text
		);
	strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));

/*
 * this is undocumented on purpose:
 * - users are not supposed to use textext("...") any more,
 *   but it's left here if one decides to create a plain metapost terminal out of it
 *
 * switch(CONTEXT_params.text) {
 * 	case CONTEXT_TEXT_BTEX    :
 * 	strncat(term_options, "btex ",
 * 		sizeof(term_options)-strlen(term_options)); break;
 * case CONTEXT_TEXT_SOMETXT  :
 * 	strncat(term_options, "sometxt ",
 * 		sizeof(term_options)-strlen(term_options)); break;
 * case CONTEXT_TEXT_TEXTEXT :
 * 	strncat(term_options, "textext ",
 * 		sizeof(term_options)-strlen(term_options)); break;
 * }
 */
	switch (CONTEXT_params.points) {
		case CONTEXT_POINTS_WITH_TEX      :
			strncat(term_options, "pointswithtex ",
				sizeof(term_options)-strlen(term_options)); break;
		case CONTEXT_POINTS_WITH_METAPOST :
			strncat(term_options, "pointswithmetapost ",
				sizeof(term_options)-strlen(term_options)); break;
	}
	strncat(term_options,"font \"",           sizeof(term_options)-strlen(term_options));
	strncat(term_options,CONTEXT_params.font, sizeof(term_options)-strlen(term_options));
	strncat(term_options,"\" ",               sizeof(term_options)-strlen(term_options));

	snprintf(tmp_term_options, sizeof(tmp_term_options),
		"%g%s", CONTEXT_params.fontsize.value, unit_name(CONTEXT_params.fontsize.unit)
		);
	strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	/* just for debugging:
	snprintf(tmp_term_options, sizeof(tmp_term_options),
		"(%d)", sizeof(term_options)
		);
	strncat(term_options, tmp_term_options, sizeof(term_options)-strlen(term_options));
	*/
}

/* *************
 * CONTEXT_init*
 * *************
 *
 * Starts a new file.
 *
 * XXX: "set term context" multiple times will only include those graphics
 *      that were create before issuing a new "set term context options"
 *      this should be fixed in the core by reopening the file
 *      (removing previously written content).
 * - PDF & binary terminals start a new file
 * - PS & TeX-based terminals continue
 */
TERM_PUBLIC void
CONTEXT_init()
{
	time_t now;
	char *timedate;

	CONTEXT_posx = CONTEXT_posy = 0;
	CONTEXT_path_count = 0;
	CONTEXT_path_is_dot = 0;

	CONTEXT_counter=0;

	/*
	 * XXX: Timoth\'ee warned me that this is not safe to use (portable);
	 *      but PostScript terminal uses the same set of commands.
	 *      Is there a way to write the timestamp in a compatible way?
	 */
	time(&now);
	timedate=asctime(localtime(&now));
	timedate[strlen(timedate)-1]='\0';

	fprintf(gpoutfile, "%% Written by ConTeXt terminal for GNUPLOT on: %s", asctime(localtime(&now)));
	fprintf(gpoutfile, "%% GNUPLOT version %s patchlevel %s\n", gnuplot_version, gnuplot_patchlevel);
	fprintf(gpoutfile, "%% See also http://wiki.contextgarden.net/Gnuplot\n%%\n");

	/* place the header first if this is a standalone graphic */
	if(CONTEXT_params.standalone) {
		/* load the gnuplot module */
		fputs("\\usemodule\n   [gnuplot]\n", gpoutfile);
		/* enable color (the only place where "color" is indeed used so far) */
		if (CONTEXT_params.color) {
			fputs("\\setupcolors\n   [state=start]\n", gpoutfile);
		}
		/* additional user-provided header information (if available) */
		if(CONTEXT_params.header) {
			fprintf(gpoutfile, "%s\n", CONTEXT_params.header);
		}
		/* for some reason setting \bodyfontenvironment is needed,
		 * otherwise \switchtobodyfont[name] doesn't work OK */
		if (!(CONTEXT_params.fontsize.value == CONTEXT_FONTSIZE && CONTEXT_params.fontsize.unit == UNIT_PT)) {
			fprintf(gpoutfile, "\\definebodyfontenvironment\n   [%g%s]\n",
				CONTEXT_params.fontsize.value,
				unit_name(CONTEXT_params.fontsize.unit));
		}
		/* set the proper font: \setupbodyfont[{fontname,}fontsize sizeunit] */
		fprintf(gpoutfile, "\\setupbodyfont\n   [%s%s%g%s]\n",
			CONTEXT_params.font,
			/* write a comma only if the last string was non-empty */
			((strlen(CONTEXT_params.font)>0) ? "," : ""),
			CONTEXT_params.fontsize.value,
			unit_name(CONTEXT_params.fontsize.unit));

		/*---------*
		 * options *
		 *---------*/
		fprintf(gpoutfile, "\\setupGNUPLOTterminal\n   [context]\n   [");
		
		/* color (gp_use_color): yes/no (true/false)
		 * default: yes
		 * - doesn't do anything useful yet;
		 *   and besides that, it's already set in \setupcolors[state=start] */
		/* fprintf(gpoutfile, "    color=%s, %% *yes* | no\n", CONTEXT_params.color ? "yes" : "no"); */
		
		/* linejoin: mitered/rounded/beveled
		 * default: mitered */
		fprintf(gpoutfile, "linejoin=");
		switch(CONTEXT_params.linejoin) {
			case LINEJOIN_MITER: fprintf(gpoutfile, "mitered"); break;
			case LINEJOIN_ROUND: fprintf(gpoutfile, "rounded"); break;
			case LINEJOIN_BEVEL: fprintf(gpoutfile, "beveled"); break;
		}
		fprintf(gpoutfile, ", %% *mitered* | rounded | beveled\n");
		
		/* linecap: butt/rounded/squared
		 * default: butt */
		fprintf(gpoutfile, "    linecap=");
		switch(CONTEXT_params.linecap) {
			case LINECAP_BUTT  : fprintf(gpoutfile, "butt"); break;
			case LINECAP_ROUND : fprintf(gpoutfile, "rounded"); break;
			case LINECAP_SQUARE: fprintf(gpoutfile, "squared"); break;
		}
		fprintf(gpoutfile, ", %% *butt* | rounded | squared\n");
		
		/* dashed (gp_use_dashed): yes/no (true/false)
		 * default: yes */
		fprintf(gpoutfile, "    dashed=%s, %% *yes* | no\n", CONTEXT_params.dashed ? "yes" : "no");
		/* dashlength (gp_scale_dashlength): 1.0 */
		fprintf(gpoutfile, "    dashlength=%g, %% scaling factor for dash lengths\n", CONTEXT_params.scale_dashlength);
		
		/* linewidth (gp_scale_linewidth): 1.0 */
		fprintf(gpoutfile, "    linewidth=%g, %% scaling factor for line widths (1.0 means 0.4bp)\n", CONTEXT_params.scale_linewidth);		

		/* textscale (gp_scale_text): 1.0 */
		/* written out just for reference - it's commented out since it needs to be part of graphic
		   and affects estimation of label sizes */
		fprintf(gpoutfile, "    %%textscale=%g, %% scaling factor for text labels\n", CONTEXT_params.scale_text);		
		
		/* points (gp_points_with): metapost/tex (gp_points_with_metapost/gp_points_with_tex)
		 * default: metapost */
		fprintf(gpoutfile, "    points=%s] %% *metapost* | tex (Should points be drawn with MetaPost or TeX?)\n",
			CONTEXT_params.points == CONTEXT_POINTS_WITH_METAPOST ? "metapost" : "tex");

		/*----------------*
		 * end of options *
		 *----------------*/

		fputs("\n\\starttext\n\n", gpoutfile);
	} else {
		/* Sorry, nothing! In non-standalone graphic, parameters make no sense.
		 * Setup everything in the file which includes such a graphic instead.
		 */
	}
}

/* ***************
 * CONTEXT_reset *
 * ***************
 *
 * finish writing the file
 */
TERM_PUBLIC void
CONTEXT_reset()
{
	/* we only have to end the document if this is a stand-alone graphic */
	if(CONTEXT_params.standalone) {
		fputs("\\stoptext\n", gpoutfile);
	} else {
		/* This means that any subsequent plots to the same file will be ignored.
		 * I don't like that - gnuplot should delete the old contents instead,
		 * just as it does in case of PNG or PDF -
		 * but it will be at least consistent with standalone graphics that way
		 */
		fputs("\\endinput\n", gpoutfile);
	}
}

/* **************
 * CONTEXT_text *
 * **************
 *
 * Ends the current graphic.
 */
TERM_PUBLIC void
CONTEXT_text()
{
	/* close and draw the current path first */
	if (CONTEXT_path_count > 0)
		CONTEXT_endpath();

	fprintf(gpoutfile, "setbounds currentpicture to unitsquare xyscaled (w,h); %% %g %g %g %g\n", xoffset, yoffset, xsize, ysize);

	/* standalone graphic is a whole-page graphic */
	if(CONTEXT_params.standalone) {
		fputs("\\stopGNUPLOTpage\n", gpoutfile);
	/* otherwise we define a MPgraphic to be included later */
	} else {
		fputs("\\stopGNUPLOTgraphic\n", gpoutfile);
	}
}

/* ******************
 * CONTEXT_graphics *
 * ******************
 *
 * Starts a new graphic.
 */
TERM_PUBLIC void
CONTEXT_graphics()
{
	/* standalone graphic is a whole-page graphic */
	if(CONTEXT_params.standalone) {
		fprintf(gpoutfile, "\\startGNUPLOTpage %% Graphic Nr. %d\n", ++CONTEXT_counter);
	/* otherwise we define a MPgraphic to be included later */
	} else {
		/* the first parameter holds the graphic number */
		fprintf(gpoutfile, "\\startGNUPLOTgraphic[%d]\n", ++CONTEXT_counter);
	}

	fprintf(gpoutfile, "gnuplotversion := \"%s\";\n", gnuplot_version);
	/*
	 * MetaPost can only handle numbers up to 4096. Too high resolution
	 * would thus result in number overflow, that's why we scale down all the
	 * integers from gnuplot by 100 and multiply those numbers later by
	 * appropriate scaling factors 'a' and 'b' to get the proper dimensions.
	 */
	fprintf(gpoutfile, "%% width and height of the figure\nw:=%g%s; h:=%g%s;\n",
		CONTEXT_params.xsize.value, unit_name(CONTEXT_params.xsize.unit),
		CONTEXT_params.ysize.value, unit_name(CONTEXT_params.ysize.unit));
	fprintf(gpoutfile, "%% horizontal and vertical scaling factors\na:=w/%.2f; b:=h/%.2f;\n",
		(term->xmax)/100.0, (term->ymax)/100.0);
	fprintf(gpoutfile, "%% temporary variable for storing the path\nsave p; path p;\n%%\n");
	fprintf(gpoutfile, "%% -------------------------\n");
	fprintf(gpoutfile, "%% Different initialisations\n");
	fprintf(gpoutfile, "%% -------------------------\n");
	fprintf(gpoutfile, "%% for additional user-defined settings\ngp_setup_before;\n");
	/* needed (depends on terminal settings & needs to be passed) */
	fprintf(gpoutfile, "%% text scaling factor for the whole figure\n");
	fprintf(gpoutfile, "gp_scale_text := %g;\n", CONTEXT_params.scale_text);
	fprintf(gpoutfile, "%% pointsize scaling factor\n");
	fprintf(gpoutfile, "gp_set_pointsize(%g);\n", CONTEXT_old_pointsize);
	/* needed (provided by terminal) */
	fprintf(gpoutfile, "%% linewidth scaling factor for individual lines\n");
	fprintf(gpoutfile, "gp_set_linewidth(%g);\n", CONTEXT_old_linewidth);
	fprintf(gpoutfile, "%% for additional user-defined settings\ngp_setup_after;\n");
	fprintf(gpoutfile, "%% -------------------------\n");

	/* since palette is initialized only once, subsequent plots wouldn't see it
	 * unless we write it on the top of relevant plots explicitely */
	if(is_plot_with_palette()) {
		CONTEXT_write_palette(CONTEXT_old_palette);
	}
	
	/* needed, otherwise the first linetype(-2) would be ignored */
	CONTEXT_old_linetype = -3;
	/* different initializations - not really needed, but they cannot hurt */
	CONTEXT_posx = CONTEXT_posy = 0;
	CONTEXT_path_count = 0;
	CONTEXT_path_is_dot = 0;
}

/* ---------------
 * CONTEXT_endpath
 * ---------------
 *
 * Closes and strokes (draws) the current path.
 *
 * It the path ends where it started, it ends it with --cycle (we get cyclic path),
 * otherwise just with a semicolon.
 */
static void
CONTEXT_endpath()
{
	/* if we have a dot, draw only the dot */
	if(CONTEXT_path_is_dot) {
		fprintf(gpoutfile, "gp_dot(%.2fa,%.2fb);\n", CONTEXT_posx / 100.0, CONTEXT_posy / 100.0);
		CONTEXT_path_is_dot = 0;
	
	/* cyclic path, so let's end it with "--cycle" */
	} else if((CONTEXT_posx == CONTEXT_path_start_x) && (CONTEXT_posy == CONTEXT_path_start_y)) {
		fputs("--cycle;\ngp_draw(p);\n", gpoutfile);
	
	/* regular non-cyclic path */
	} else {
		fputs(";\ngp_draw(p);\n", gpoutfile);
	}

	/* we're not inside path any more */
	CONTEXT_path_count = 0;
}

/* **************
 * CONTEXT_move *
 * **************
 *
 * Remembers the new location for a path.
 *
 * If it doesn't differ from the current location, this is simply ignored.
 * If we're still in the middle of path construction and location differs,
 * it strokes the old path.
 *
 */
TERM_PUBLIC void
CONTEXT_move(unsigned int x, unsigned int y)
{
	/* we seem to be there already */
	if((x == CONTEXT_posx) && (y == CONTEXT_posy))
		return;

	/* close and draw the current path before the move */
	if(CONTEXT_path_count > 0)
		CONTEXT_endpath();

	CONTEXT_posx = x;
	CONTEXT_posy = y;
}

/* -----------------
 * CONTEXT_startpath
 * -----------------
 *
 * Starts ([but not yet] drawing) a new path.
 */
static void
CONTEXT_startpath()
{
	CONTEXT_path_start_x = CONTEXT_posx;
	CONTEXT_path_start_y = CONTEXT_posy;
	CONTEXT_path_count = 2;

	fprintf(gpoutfile, "p := (%.2fa,%.2fb)", CONTEXT_posx / 100.0, CONTEXT_posy / 100.0);
}

/* ****************
 * CONTEXT_vector *
 * ****************
 *
 * Prolongs the current path for an additional line (from the last point to (x,y))
 * unless it has a zero-length.
 *
 * Points have to be treated as a special case, since gnuplot sometimes tries
 * to draw them as moveto(a,b)--lineto(a,b) - without the proper linecap,
 * that wouldn't draw anything in MetaPost or PS.
 * (I hope that I got that part right, but I'm not completely sure.)
 */
TERM_PUBLIC void
CONTEXT_vector(unsigned int x, unsigned int y)
{
	/* this is zero-length line (or a dot)
	 *
	 * stupid background, has to handle
	 * - move(0,0), vector(0,0), whatever: draw a dot
	 * - move(0,0), vector(0,0), vector (1,1): draw a line
	 */
	if((x == CONTEXT_posx) && (y==CONTEXT_posy)) {
		/* as long as this is still a dot candidate, mark it so
		 * however - further vector() commands may set this back to 0 */
		if(CONTEXT_path_count == 0) {
			CONTEXT_path_is_dot = 1;
		}
		/* if some path was already drawn up to this place, ignore (it's not a dot) */
		return;
	}

	/* start the path if none is started yet */
	if(CONTEXT_path_count == 0) {
		/* the path is not a dot */
		CONTEXT_path_is_dot = 0;
		CONTEXT_startpath();
	} else {
		/* or prevent too long lines if you're in the middle of a path */
		if((CONTEXT_path_count % CONTEXT_LINEMAX) == 1) {
			fputs("\n  ", gpoutfile);
			CONTEXT_path_count = 1;
		}
	}

	CONTEXT_posx = x;
	CONTEXT_posy = y;
	fprintf(gpoutfile, "--(%.2fa,%.2fb)", CONTEXT_posx / 100.0, CONTEXT_posy / 100.0);
	CONTEXT_path_count++;
}

/* ******************
 * CONTEXT_linetype *
 * ******************
 *
 * - If only color has been changed (recently), but not the linetype,
 *   it resets only the color.
 * - If linetype was changed, it sets the new linetype
 */
TERM_PUBLIC void
CONTEXT_linetype(int lt)
{
	/* reset the color in case it has been changed in CONTEXT_set_color() */
	if (CONTEXT_old_linetype != lt || CONTEXT_color_changed) {
		/* close and draw the current path first */
		if (CONTEXT_path_count > 0)
			CONTEXT_endpath();

		fprintf(gpoutfile, "gp_set_linetype(%d);\n", lt);

		CONTEXT_old_linetype = lt;
		CONTEXT_color_changed = FALSE;
	}
}

/* ******************
 * CONTEXT_put_text *
 * ******************
 *
 * Places text labels.
 */
TERM_PUBLIC void
CONTEXT_put_text(unsigned int x, unsigned int y, const char str[])
{
	const char *s; /* pointer to string */
	int  alignment = 0;
	char alignments[3][10] = {"center", "left", "right"};

	/* ignore empty strings */
	if (!str || !strlen(str))
		return;

	/* close and draw the current path first */
	if (CONTEXT_path_count > 0)
		CONTEXT_endpath();

	/* see the values of "alignments" above */
	switch (CONTEXT_justify) {
		case CENTRE:
			alignment = 0;
			break;
		case LEFT:
			alignment = 1;
			break;
		case RIGHT:
			alignment = 2;
			break;
	}

	/* remove whitespaces at the beginning of string
	 * (usually problem in positive numbers)
	 * They interfere with positioning: whitespace at the beginning takes
	 * some place although it's invisible, so left-aligned and centered labels
	 * are posioned wrong otherwise.
	 * Example:
	 *   -1 0 1 2: centered labels on x axis
	 * if we had a space in front, positive numbers would be "centered" in a weird way*/
	for(s=str; s[0] == ' '; s++);

	/* label position */
	fprintf(gpoutfile, "gp_put_text((%.2fa, %.2fb), ", x/100.0, y/100.0);
	/* angle of rotation - optional and needed only if it's different from 0 */
	if (CONTEXT_ang != 0) {
		fprintf(gpoutfile, "angle(%d), ", CONTEXT_ang);
	}
	/* alignment - "center" is optional, but we'll add it anyway */
	/* + \sometxt */
	fprintf(gpoutfile, "align(%s), \\sometxt[gp]", alignments[alignment]);
	/* fontface/fontsize - optional second argument */
	if(CONTEXT_font_explicit[0] != 0)
		fprintf(gpoutfile, "[%s]", CONTEXT_font_explicit);
	/* finally the text label itself */
	fprintf(gpoutfile, "{%s});\n", s);
}


/* ********************
 * CONTEXT_text_angle *
 * ********************
 *
 * Saves text angle to be used for text labels.
 */
TERM_PUBLIC int
CONTEXT_text_angle(int ang)
{
    CONTEXT_ang = ang;
    return TRUE;
}

/* **********************
 * CONTEXT_justify_text *
 * **********************
 *
 * Saves horizontal text justification (left/middle/right) to be used for text labels.
 */
TERM_PUBLIC int
CONTEXT_justify_text(enum JUSTIFY mode)
{
    CONTEXT_justify = mode;
    return TRUE;
}

/* ***************
 * CONTEXT_point *
 * ***************
 *
 * There are two/three possible ways of drawing points in ConTeXt:
 * - let the gnuplot draw the points with standard move/vector commands
 *   (points_default): not enabled
 * - use the points predefined in mp-gnuplot.mp (drawn with metapost)
 *   which can easily be redefined
 *   (points_with_metapost)
 * - use symbols from a symbol set predefined in m-gnuplot.tex (drawn with TeX)
 *   (points_with_tex)
 *
 * At first this routine took care of that, but now it's up to the high-level
 * user interface to switch between the last two options.
 */
TERM_PUBLIC void
CONTEXT_point (unsigned int x, unsigned int y, int number)
{
	/* finish the current line first before the move */
	if(CONTEXT_path_count > 0)
		CONTEXT_endpath();

	fprintf(gpoutfile, "gp_point(%.2fa,%.2fb,%d);\n", x/100.0, y/100.0, number);

	/*
	 * This is how the points were draw at the beginning when macros
	 * for enclusion of TeX portions weren't as advanced as they're now.
	 * Currently there is some trickery involved which enabled simpler
	 * definitions of points that have to be typeset with TeX.
	 *
	 * See m-gnuplot.tex for details.
	 *
	 * This portion of code is left here for historical reasons.
	 * It might be needed again if clean metapost code will ever be produced
	 * with this terminal.
	 *
	// use the points defined in the module (drawn with metapost)
	if(CONTEXT_params.points == CONTEXT_POINTS_WITH_METAPOST) {
		fprintf(gpoutfile, "gp_point(%.2fa,%.2fb,%d);\n", x/100.0, y/100.0, number);
	// use the points defined in the module (typeset with TeX)
	} else if(CONTEXT_params.points == CONTEXT_POINTS_WITH_TEX) {
		// change \sometxt{\GPpoint{N}} to \GPpoint{N}
		fprintf(gpoutfile, "gp_point(%.2fa,%.2fb,\\sometxt{\\GPpoint{%d}});\n", x/100.0, y/100.0, number);
	} else {
		// should not happen unless there's an error in this terminal
		// or, if one will ever want the old "btex ... etex" functionality,
		// it might fit in here
	}
	*/
}

/* ***************
 * CONTEXT_arrow *
 * ***************
 * ConTeXt could draw nice arrows on its own and in such a way that user could
 * simply redefine arrow heads in the template file.
 *
 * This function is left here just in case that anyoune would find it useful
 * to define his own arrow-drawing commands.
 *
 * Currently it just calls the default gnuplot function for drawing arrows.
 */
TERM_PUBLIC void
CONTEXT_arrow (unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, int head)
{
	do_arrow(sx, sy, ex, ey, head);
}

/* ------------------------
 * CONTEXT_fontstring_parse 
 * ------------------------
 *
 * Parses from_string, which is divided by commas (,)
 * and copies the whole content to to_string except for the part
 * which starts with a numeric value.
 *
 * That value is interpreted separately, saved into dimension
 * and used for setting the proper font size.
 *
 * Only the latest valid dimension provided is stored.
 * If dimension->value is 0, it means that no font size has been provided in the string
 *
 * to_size is the size of to_string which may not be exceeded while copying the string
 */
static void
CONTEXT_fontstring_parse(char *from_string, char *to_string, int to_size, dimension_t *dimension)
{
	int i;
	char c;
	char tmp_fontsize[MAX_ID_LEN+1], unit[MAX_ID_LEN+1];
	/* temporary place for storing dimenstion -
	 * we will only store the latest valid dimension
	 * and ignore any other fields starting with a number and not containing a valid dimension */
	dimension_t tmp_dimension;
	float size;

	/* positions in input string between two commas (or start/stop) */
	int from_start=0, from_stop=0;
	/* last used position in output string */
	int to_stop=0;

	/* font size zero is forbidden anyway;
	 * the output value zero means: no size has been set, so this field will be ignored */
	dimension->value = 0;
	dimension->unit  = UNIT_PT;

	/* let's walk from comma to comma (or from start to stop)
	 * and analyse content of each string separately */
	/* as long as we don't hit the end of the string */
	for (; (from_stop < strlen(from_string)) && (to_stop < to_size); from_start = ++from_stop) {
		/* find next specification of font name/family/size/... between two commas */
		while (from_string[from_stop] != 0 && from_string[from_stop] != ',') from_stop++;

		/* if this looks like a real number (+ optional unit), parse interpret it as font size */
		if (from_string[from_start] == '.' || (from_string[from_start]+1 > '0' && from_string[from_start]-1 < '9')) {
			/* copy the content to tmp_string first */
			for (i=0; i < sizeof(tmp_fontsize) && i < (from_stop-from_start); i++) {
				tmp_fontsize[i] = from_string[from_start+i];
			}
			tmp_fontsize[i] = 0;
			/* parse the value & unit */
			unit[0] = 0; /* if no unit is given, we should get an empty string */
			sscanf(tmp_fontsize, "%f%s", &size, unit);
			tmp_dimension.value = size;
			/* if no unit given - default to pt */
			if (unit == NULL || strlen(unit)==0) {
				tmp_dimension.unit  = UNIT_PT;
			/* otherwise determine the unit first */
			} else {
				tmp_dimension.unit  = string_to_unit(unit);
			}
			/* pixel is not a valid unit for a font size */
			if (tmp_dimension.unit == UNIT_PX)
				tmp_dimension.unit = UNIT_OTHER;

			/*
			 * store the size, but only if the size is valid and makes sense
			 *
			 * we want the font to be:
			 * - at least 3pt
			 * - at most half the height of the plot
			 */
			if(tmp_dimension.unit != UNIT_OTHER) {
				if(convert_to_unit(tmp_dimension,UNIT_PT)*CONTEXT_params.scale_text > 3 &&
				   convert_to_unit(tmp_dimension,UNIT_PT)*CONTEXT_params.scale_text < 0.5*convert_to_unit(CONTEXT_params.ysize,UNIT_PT)) {
					dimension->value = tmp_dimension.value;
					dimension->unit  = tmp_dimension.unit;
				}
			}

		/* otherwise copy the content (almost) literally
		 * from_stop can be a comma or 0 - in either case we simply copy that one as well */
		} else {
			for (i=from_start; i < from_stop+1; i++) {
				c = from_string[i];
				/* TODO: improve this filter - remove any other dangerous characters
				 *       Do we need to remove {} ? */
				if (!(c==']' || c=='[' || c=='$' || c=='#' ||
					   c=='%' || c=='^' || c=='_' || c=='`' ||
					   c=='\\' || c=='\n' || c=='\t' || c=='\r')) {
					/* we may only write up to the pre-last character of to_string */
					if (to_stop < to_size) {
						to_string[to_stop++] = c;
					}
				}
			}
		}
	}
	
	/* it might have happened that the last character we wrote was a comma instead of 0,
	 * so we have to make sure that we finish the string */
	to_string[to_stop-1] = 0;
}

/* -------------------------
 * CONTEXT_adjust_dimensions
 * -------------------------
 *
 * - sets the v_char and h_char based on current font size (approximation only)
 *   using CONTEXT_fontsize in points (from CONTEXT_params.fontsize) and CONTEXT_params.scale_text
 * - sets xmax and ymax based on CONTEXT_params.xsize and CONTEXT_params.ysize
 */
static void
CONTEXT_adjust_dimensions()
{
	/* sets vertical dimension of characters based on current fontsize in pt */
	term->v_char = (unsigned int)((double)CONTEXT_DPI *
		convert_to_unit(CONTEXT_fontsize,UNIT_IN) * CONTEXT_params.scale_text);
	/* based on proportions of LM digits at 12pt */
	term->h_char = (unsigned int)(CONTEXT_LM_H_TO_V_RATIO*term->v_char);

	/* we might want to fix CONTEXT_DPI in case that the figure becomes too big */
	term->xmax = (unsigned int)((double)CONTEXT_DPI * convert_to_unit(CONTEXT_params.xsize,UNIT_IN) );
	term->ymax = (unsigned int)((double)CONTEXT_DPI * convert_to_unit(CONTEXT_params.ysize,UNIT_IN) );
}

/* *****************
 * CONTEXT_set_font*
 * *****************
 *
 * Official description:
 * - empty string restores the terminal's default font
 * - fonts are selected as strings "name,size",
 *   where size should be a floating point number by default, interpreted as "pt" (point)
 *
 * It's the user's own responsibility to make sure that the proper typescripts
 * are included in the header, else the selected font won't work out-of-the-box
 *
 * The ConTeXt terminal should support things such as
 *   "iwona,12pt,ss" (sans serif)      or
 *   "palatino,10dd" (10 didot points) or
 *   "tt"            (typewriter)      or
 * as well
 *
 * The routine saves font name to CONTEXT_font
 * and fontsize to CONTEXT_fontsize.
 *
 * The two are joined in CONTEXT_font_explicit for the usage in
 *   \sometxt[gp][fontname,fontsize]{label}
 */
TERM_PUBLIC int
CONTEXT_set_font(const char *font)
{
	char tmp_fontstring[MAX_ID_LEN+1] = "";

	/* saves font name & family to CONTEXT_font */
	CONTEXT_fontstring_parse((char *)font, CONTEXT_font, sizeof(CONTEXT_font), &CONTEXT_fontsize_explicit);
	strncpy(CONTEXT_font_explicit, CONTEXT_font, sizeof(CONTEXT_font_explicit));
	
	/* valid fontsize has been provided */
	if (CONTEXT_fontsize_explicit.value > 0) { /* XXX: if valid */

		CONTEXT_fontsize.value = CONTEXT_fontsize_explicit.value;
		CONTEXT_fontsize.unit  = CONTEXT_fontsize_explicit.unit;

		snprintf(tmp_fontstring, sizeof(tmp_fontstring),
			",%g%s", CONTEXT_fontsize_explicit.value, unit_name(CONTEXT_fontsize_explicit.unit)
		);
		strncat(CONTEXT_font_explicit, tmp_fontstring, sizeof(CONTEXT_font_explicit)-strlen(CONTEXT_font_explicit));

	/* no fontsize has been provided: switch back to default terminal fontsize */
	} else if (CONTEXT_fontsize_explicit.value == 0) {
		CONTEXT_fontsize.value = CONTEXT_params.fontsize.value;
		CONTEXT_fontsize.unit  = CONTEXT_params.fontsize.unit;
	}

	/* tell to gnuplot how big the fonts in labels are */
	CONTEXT_adjust_dimensions();

	return TRUE;
}

/* *******************
 * CONTEXT_pointsize *
 * *******************
 *
 * Sets the (relative) point size for subsequent points
 *
 * The base point size is defined "somewhere else":
 * - depends on the font[size] used when "pointswithtex" option is on
 */
TERM_PUBLIC void
CONTEXT_pointsize(double pointsize)
{
	/*
	 * my first thought was not to allow negative sizes of points,
	 * but I see no reason why one shouldn't be able to play with
	 * inverted point shapes, so finally I commented this out again
	 *
	 *   if(pointsize < 0)
	 *      pointsize = 1;
	 */
	
	if(CONTEXT_old_pointsize != pointsize) {
		/* close and draw the current path first */
		if (CONTEXT_path_count>0)
			CONTEXT_endpath();
		fprintf(gpoutfile, "gp_set_pointsize(%.3lf);\n", pointsize);
		CONTEXT_old_pointsize = pointsize;
	}
}

/* *****************
 * CONTEXT_fillbox *
 * *****************
 *
 * Creates the path for the rectangle and calls the CONTEXT_fill(style)
 * routine (shared with CONTEXT_filled_polygon) to actually fill that shape
 */
TERM_PUBLIC void
CONTEXT_fillbox(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)
{
	/* close and draw the current path first */
	if (CONTEXT_path_count > 0)
		CONTEXT_endpath();

	/* create a new path */
	fprintf(gpoutfile, "p := unitsquare xyscaled (%.2fa,%.2fb) shifted (%.2fa,%.2fb);\n", width/100.0, height/100.0, x1/100.0, y1/100.0);
	
	/* fills the box according to the "style"
	 * the code went out of this routine because of undocumented behaviour
	 * that also the filled_polygon should paint with patterns ... */
	CONTEXT_fill(style);
}

/* **************
 * CONTEXT_fill *
 * **************
 *
 * Filling routine, yet another undocumented feature of Gnuplot.
 * The code was mostly cloned from the PostScript terminal,
 * so that you know whom to accuse if it doesn't do what you would expect
 * it to do. (In case of cloning errors please inform the author of this terminal.)
 *
 * The lowest 4 bits of "style" seem to represent the style of filling
 * (whether it is solid or pattern-based or whatever that might appear
 * in that place in the future).
 *
 * The rest of the bits of "style" represent either the density
 * (ranging from 0 to 100) or the number of the pattern that the polygon
 * should be filled with.
 *
 * Used by CONTEXT_fillbox(...) and CONTEXT_filled_polygon(...)
 */
TERM_PUBLIC void
CONTEXT_fill(int style)
{
	int density;
	int pattern;

	/* used in FS_[TRANSPARENT_]SOLID --> fill with intensity according to filldensity 
	   it extracts a percentage out of "style" */
	density = (style >> 4);
	if(density < 0)
		density = 0;
	if(density > 100)
		density = 100;

	fputs("gp_fill(p", gpoutfile);

	/* do some strange trickery */
	switch(style & 0xf) {

	case FS_TRANSPARENT_SOLID:
		/* just a flag to tell the terminal that density() should be used to interpret transparency */
		fprintf(gpoutfile, ",transparent");
	case FS_SOLID:
		/* fill the box with density "density": if no parameter density is specified,
		   it implies 100% density by default */
		if (density < 100) {
			fprintf(gpoutfile, ",density(%.2f)", density*0.01);
		}
		break;

	case FS_TRANSPARENT_PATTERN:
		/* just a flag that should be interpreted in metapost, bun no idea what transparent pattern means */
		fprintf(gpoutfile, ",transparent");
	case FS_PATTERN:
		pattern = (style >> 4);
		fprintf(gpoutfile, ",pattern(%d)", pattern);
		break;

	default: /* style == 0 (FS_EMPTY) or unknown --> fill with background color */
		fprintf(gpoutfile, ",density(0)");
	}
	/* TODO: FS_DEFAULT is missing; what should that one do? */

	/* gp_fill(p,...); */
	fputs(");\n", gpoutfile);
}

/* *******************
 * CONTEXT_linewidth *
 * *******************
 *
 * scale line width (similar to pointsize)
 * remembers the values locally (no serious need for that actually) and writes them into file
 */
TERM_PUBLIC void
CONTEXT_linewidth(double linewidth)
{
	if(linewidth < 0)
		linewidth = 1.0;
	
	if (CONTEXT_old_linewidth != linewidth) {
		/* close and draw the current path first */
		if (CONTEXT_path_count>0)
			CONTEXT_endpath();
		fprintf(gpoutfile, "gp_set_linewidth(%.3lf);\n", linewidth);
		CONTEXT_old_linewidth = linewidth;
	}
}

/* ------------------------------
 * CONTEXT_write_palette_gradient
 * ------------------------------
 *
 * Writes the colors and positions for a gradient pallete.
 */
static void
CONTEXT_write_palette_gradient(gradient_struct *gradient, int cnt)
{
	int i;
	
	/* i-th color */
	fprintf(gpoutfile, "colors(");
	for (i=0; i<cnt; i++) {
		if(i>0) { fprintf(gpoutfile, ","); }
		fprintf(gpoutfile, "(%.3g,%.3g,%.3g)", gradient[i].col.r, gradient[i].col.g, gradient[i].col.b);
	}
	
	/* position of the i-th color */
	fprintf(gpoutfile, ");positions(");
	for (i=0; i<cnt; i++) {
		if(i>0) { fprintf(gpoutfile, ","); }
		fprintf(gpoutfile, "%.4g", gradient[i].pos);
	}
	fprintf(gpoutfile, ")");
}

/* ---------------------
 * CONTEXT_write_palette
 * ---------------------
 *
 */
static void
CONTEXT_write_palette (t_sm_palette *palette)
{
	if (palette == NULL) {
		return;
	}

/* TODO
	// Color models: RGB, HSV, CMY, YIQ, XYZ
	//
	// RGB: Red, Green, Blue
	// HSV: Hue, Saturation, Value
	// CMY
	//
	// two models that gnuplot uses, but which probably won't be supported by this terminal:
	// YIQ: U.S. Commercial Television Briadcasting (almost RGB)
	// XYZ: three primary colors of the color model defined by the 'Commission Internationale de l'Eclairage' (CIE)
	// http://www.cs.rit.edu/~ncs/color/glossary.htm
	// http://cs.fit.edu/wds/classes/cse5255/cse5255/davis/index.html
*/
	fprintf(gpoutfile, "gp_make_palette(");
	switch(sm_palette.colorMode) {
		/* grayscale only */
		case SMPAL_COLOR_MODE_GRAY:
			fprintf(gpoutfile, "color_mode(gray)");
			// XXX: I'm not sure if something has to be done here or not
			break;
		/* one of several fixed transformations */
		case SMPAL_COLOR_MODE_RGB:
			fprintf(gpoutfile, "color_mode(rgb);formulae(%d,%d,%d)",
				sm_palette.formulaR,
				sm_palette.formulaG,
				sm_palette.formulaB);
			break;
		/* user defined transforms */
		case SMPAL_COLOR_MODE_FUNCTIONS:
			fprintf(gpoutfile, "color_mode(functions)");
			break;
		/* interpolated table: explicitely defined or read from file */
		case SMPAL_COLOR_MODE_GRADIENT:
			fprintf(gpoutfile, "color_mode(gradient);");
			CONTEXT_write_palette_gradient(palette->gradient, palette->gradient_num);
			break;
		case SMPAL_COLOR_MODE_NONE:
			break;
		default:
			break;
	}
	fprintf(gpoutfile, ");\n");
}

/* *********************
 * CONTEXT_make_palette*
 * *********************
 *
 * 1. if palette==NULL, then return nice/suitable
 * maximal number of colours supported by this terminal.
 * Returns 0 if it can make colours without palette (like
 * postscript).
 * 2. if palette!=NULL, then allocate its own palette
 * return value is undefined
 * 3. available: some negative values of max_colors for whatever
 * can be useful
 */
TERM_PUBLIC int
CONTEXT_make_palette (t_sm_palette *palette)
{
	if (palette == NULL) {
		return 0;  /* ConTeXt can do continuous colors */
	}
	
	/* save the palette */
	CONTEXT_old_palette = palette;
	
	return 0;
}


/*
 * most probably this one is not needed
 *
 * TERM_PUBLIC void
 * CONTEXT_previous_palette(){}
 *
 */

/* *******************
 * CONTEXT_set_color *
 * *******************
 *
 * typedef struct t_colorspec {
 *    int    type;    // TC_ DEFAULT, LT, LINESTYLE, RGB, CB, FRAC, Z
 *    int    lt;      // used for TC_LT, TC_LINESTYLE and TC_RGB
 *    double value;   // used for TC_CB and TC_FRAC
 * } t_colorspec;
 */
TERM_PUBLIC void
CONTEXT_set_color (t_colorspec *colorspec)
{
	double gray, r, g, b;
	/* ConTeXt doesn't offer full support for palettes yet
	   (I don't know how to trick metapost to accept the full palette specification)
	   so we convert the colors from palettes to RGB instead.
	   If terminal starts supporting palettes, this behaviour will change.
	*/
	rgb_color rgb1;

/* If (colorspec->type == TC_FRAC):
   Set current color according to colorspec->value, where 0 <= value <= 1.
   If using a palette, first map value to an integer i in the interval
   [0...num_colors-1], then set to the ith color in the palette.
   If (colorspec->type == TC_RGB):
   Set current color to the rgb triple given in colorspec->lt. */

	/* close and draw the current path first */
	if(CONTEXT_path_count > 0)
		CONTEXT_endpath();

	switch (colorspec->type) {

	/* TC_DEFAULT, TC_CB, TC_Z: probably unused; what about linestyle? */

	/* color equal as that of linetype in colorspec->lt */
	case TC_LT:
		fprintf(gpoutfile, "gp_set_color(lt(%d));\n", colorspec->lt);
		CONTEXT_color_changed = TRUE;
		break;

	/* rgb color */
	case TC_RGB:
		r = (double)((colorspec->lt >> 16 ) & 255) / 255.;
		g = (double)((colorspec->lt >> 8 ) & 255) / 255.;
		b = (double)(colorspec->lt & 255) / 255.;

		fprintf(gpoutfile, "gp_set_color(rgb(%3.2f,%3.2f,%3.2f));\n", r, g, b);
		CONTEXT_color_changed = TRUE;
		break;

	/* map [0:1] to gray colors or to the corresponding color from the palette */
	case TC_FRAC:
		gray = colorspec->value;

		/* limit negative and >1 values to [0:1] first */
		if(gray < 0) gray = 0;
		if(gray > 1) gray = 1;

		/* TODO: if ConTeXt start supporting palettes, we'll uncomment the following: */
		fprintf(gpoutfile, "%%gp_set_color(frac(%.4f));\n", gray);
		/* but now it doesn't, so let's use the fallback instead: */
		rgb1maxcolors_from_gray(gray, &rgb1);
		fprintf(gpoutfile, "gp_set_color(rgb(%3.2f,%3.2f,%3.2f));\n", rgb1.r, rgb1.g, rgb1.b);

		CONTEXT_color_changed = TRUE;
		break;
	default:
		int_warn(NO_CARET,"context.trm set_color unknown colorspec->type %i", colorspec->type);
		break;
	}
}


/* ************************
 * CONTEXT_filled_polygon *
 * ************************
 *
 * Draws a polygon with the fill color set by set_color, and no border.
 */
TERM_PUBLIC void
CONTEXT_filled_polygon (int points, gpiPoint *corners)
{
	int i;

	/* nothing to be filled if less than 3 points */
	if(points < 3)
		return;

	/* close and draw the current path first */
	if(CONTEXT_path_count > 0) {
		CONTEXT_endpath();
	}

	/* if the first point equals the last one, skip the last point; --cycle does that already
	 * this condition is probably always true in gnuplot, so the if condition may not be needed */
	if((corners[0].x == corners[points-1].x) && (corners[0].y == corners[points-1].y)) {
		points--;
	}

	/* create new path with corners */
	fputs("p := ", gpoutfile);
	fprintf(gpoutfile, "(%.2fa,%.2fb)", corners[0].x/100.0, corners[0].y/100.0);
	for (i=1; i<points; i++) {
		if (i % CONTEXT_LINEMAX == 0)
			fputs("\n  ", gpoutfile);
		fprintf(gpoutfile, "--(%.2fa,%.2fb)", corners[i].x/100.0, corners[i].y/100.0);
	}
	/* and fill it */
	fprintf(gpoutfile, "--cycle;\n");

	/* fill the polygon
	 * undocumented gnuplot behaviour, copied from PostScript terminal
	 * see comments for CONTEXT_fill for details */
	CONTEXT_fill(corners->style);
}

/*
 * TODO: figure out first how this can be done/
 *       additional support has to be implemented in pdfTeX and/or ConTeX to support
 *       efficient inclusion of bitmap images
 * (this is a placeholder and a reminder that it has to me finished)

#ifdef WITH_IMAGE

TERM_PUBLIC void
CONTEXT_image (unsigned M, unsigned N, coordval *image, gpiPoint *corner, t_imagecolor color_mode)
{
}

#endif
*/

/*
 * TODO: Implement this function for smooth shading
 *
 * you need to fix draw_color_smooth_box(MODE_SPLOT) in graph3d.c -> color.c
 *
static void
CONTEXT_draw_inside_color_smooth_box()
{
}
 */

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(context_driver)
	"context", "ConTeXt with MetaFun (for PDF documents)",
	CONTEXT_XMAX, CONTEXT_YMAX, CONTEXT_VCHAR, CONTEXT_HCHAR,
	CONTEXT_VTIC, CONTEXT_HTIC, CONTEXT_options, CONTEXT_init,
	CONTEXT_reset, CONTEXT_text, null_scale, CONTEXT_graphics,
	CONTEXT_move, CONTEXT_vector,
	CONTEXT_linetype, CONTEXT_put_text, CONTEXT_text_angle,
	CONTEXT_justify_text, CONTEXT_point, CONTEXT_arrow, CONTEXT_set_font,
	CONTEXT_pointsize,
	TERM_BINARY /* flags */, 0 /* suspend */, 0 /* resume*/, /* XXX: why did I put binary here? */
	CONTEXT_fillbox, CONTEXT_linewidth
#ifdef USE_MOUSE
	, 0, 0, 0, 0, 0 /* no mouse support */
#endif /* USE_MOUSE */
	, CONTEXT_make_palette,
	0, /* XXX: CONTEXT_previous_palette: not sure if we need it at all (PS does "grestore") */
	CONTEXT_set_color,
	CONTEXT_filled_polygon,
	0,       /* image; TODO: implement it (CONTEXT_image) */
	0, 0, 0, /* No enhanced text mode because this is TeX */
	0,       /* layer (used to signal front/back text, used in canvas, PS, epslatex, ...); XXX: figure out what this has to do */
	0        /* path (Path control for end-joins of closed polygons on PostScript-like devices); TODO: implement it (CONTEXT_path) */
TERM_TABLE_END(context_driver)
#undef LAST_TERM
#define LAST_TERM context_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */

#ifdef TERM_HELP
START_HELP(context)
"1 ConTeXt",
"?commands set terminal context",
"?set terminal context",
"?set term context",
"?terminal context",
"?term context",
"?context",
" ConTeXt is a macro package for TeX, highly integrated with Metapost",
" (for drawing figures) and intended for creation of high-quality PDF documents.",
" The terminal outputs Metafun source, which can be edited manually,",
" but you should be able to configure most things from outside.",
"",
" For an average user of ConTeXt + gnuplot module it's recommended to refer to",
" `Using ConTeXt` rather than reading this page",
" or to read the manual of the gnuplot module for ConTeXt.",
"",
" The `context` terminal supports the following options:",
" ",
" Syntax:",
"    set term context {default}",
"                     {defaultsize | size <scale> |",
"                      size <xsize> {in|cm}, <ysize> {in|cm}}",
"                     {input | standalone}",
"                     {noheader | header \"<header>\"}",
"                     {color | colour | monochrome}",
"                     {mitered | rounded | beveled}",
"                     {butt | round | squared}",
"                     {dashed | solid}",
"                     {dashlength | dl <DL>}",
"                     {linewidth | lw <LW>}",
"                     {textscale <textscale>}",
"                     {pointswithmetapost | pointswithmp | pointswithtex}",
"                     {defaultfont | font {<fontsize>} |",
"                      font \"<fontname>{,<fontsize>}\" {fontsize}}",
"",
" In non-standalone (`input`) graphic only parameters `size` to select graphic",
" size, `textscale` to scale all the labels for a factor <scale>",
" and font size, make sense, the rest is silently",
" ignored and should be configured in the .tex file which inputs the graphic."
" It's highly recommended to set the proper fontsize if document font differs from",
" 12pt, so that gnuplot will know how much space to reserve for labels.",
"",
" `default` resets all the options to their default values.",
"",
" `defaultsize` sets the plot size to 5in,3in.\n",
" `size` <scale> sets the plot size to <scale> times <default value>.",
" If two arguments are given (separated with ','), the first one sets",
" the horizontal size and the second one the vertical size.",
" Size may be given without units (in which case it means relative to the default",
" value), with inches ('in') or centimeters ('cm').",
"",
" `input` (default) creates a graphic that can be included into another ConTeXt",
" document.\n",
" `standalone` adds some lines, so that the document might be compiled as-is.",
" You might also want to add `header` in that case.",
"",
" Use `header` for any additional settings/definitions/macros",
" that you might want to include in a standalone graphic. `noheader` is the default.",
"",
" `color` to make color plots is the default, but `monochrome` doesn't do anything special yet.",
" If you have any good ideas how the behaviour should differ to suit the monochrome printers better,",
" your suggestions are welcome.",
"",
" `mitered` (default), `rounded` and `beveled` control the shape of line joins.",
" `butt` (default), `round` and `squared` control the shape of line caps.",
" See PostScript or PDF Reference Manual for explanation. For wild-behaving functions",
" and thick lines",
" you might want to use `rounded` and `round` to prevent sharp corners in line joins.",
" (Some general support for this should be added to Gnuplot, so that the same options",
" could be set for each line (style) separately).",
"",
" `dashed` (default) uses different dash patterns for different line types,"
" `solid` draws all plots with solid lines.",
"",
" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>.",
" `linewidth` or `lw` scales all linewidths by <LW>."
" (lw 1 stands for 0.4bp, which is the default line width when drawing with Metapost.)",
" `textscale` scales text labels for factor <textscale> relative to default document font.",
"",
" `pointswithmetapost` uses predefined point shapes, drawn in Metapost.",
" `pointswithtex` uses easily configurable set of symbols, defined with ConTeXt",
" in the following way:",
"  \\defineconversion[my own points][+,{\\ss x},\\mathematics{\\circ}]",
"  \\setupGNUPLOTterminal[context][points=tex,pointset=my own points]",
"",
" With `font` you can set font name and size in standalone graphics.",
" In non-standalone (`input`) mode only the font size is important",
" to reserve enough space for text labels.",
"  set term context font \"myfont,ss\" 10pt",
" will result in",
"  \\setupbodyfont[myfont,ss,10pt]",
" If you additionaly set `textscale` to 0.8 for example,",
" then the resulting font will be 8pt big and",
"  set label ... font \"myfont,12pt\"",
" will come out as 9.6pt.\n",
" For compatibility with other terminals font size may be specified without units,",
" in which case the default unit \"pt\" will be appended to it, but you can also",
" use any other supported unit, for example \"11dd\".\n",
" However, it's your own responsibility to use the proper typescript,",
" otherwise switching the font will have no effect.\n",
" For an already supported font you can use",
"    set terminal context standalone header '\\usetypescript[iwona][ec]' \\",
"        font \"iwona,ss,11pt\"",
" If you also need your own typescripts, then you could write",
"    set terminal context standalone \\",
"        header '\\usetypescriptfile[type-myfont] \\usetypescript[myfont][uc]' \\",
"        font \"myfont\" 10pt",
"",
" Note: The examples with typescripts above might become obsolete",
" with new versions of (pdf)TeX and already differ in XeTeX. They should be regarded",
" only as examples of the usage inside gnuplot.",
" Please take a look into ConTeXt documentation, wiki or mailing list (archives)",
" for any up-to-date information about font usage."
"",
" Examples:",
"    set terminal context size 1.5           # 7.5in, 4.5in",
"    set terminal context size 10cm, 5cm     # 10cm, 5cm",
"    set terminal context size 4/5, 2.54*4cm # 4in, 4in",
" For standalone (whole-page) plots with labels in UTF-8 encoding:",
"    set terminal context standalone header '\\enableregime[utf-8]'",
"",
/* TODO: LaTeX formatting */
"2 Requirements",
" - files from http://modules.contextgarden.net/gnuplot",
"",
" - please use the latest version of ConTeXt if possible (but at least one from 2007 or newer)",
"",
" - texmfstart has to be in PATH - teTeX is too old to process your files",
"",
" - if you want to call gnuplot on-the-fly, you need to have write18 enabled",
" (on most TeX distributionts this can be set with shell_escape=t in texmf.cnf)",
"",
" See http://wiki.contextgarden.net/Gnuplot for details about this terminal",
" and for more exhaustive help & examples.",
"2 Calling gnuplot from ConTeXt",
" The easiest way to make plots in ConTeXt documents is",
"    \\usemodule[gnuplot]",
"    \\starttext",
"    \\section{How to make nice plots with {\\sc gnuplot}}",
"    \\startGNUPLOTscript[sin]",
"    plot sin(x)",
"    \\stopGNUPLOTscript",
"    \\useGNUPLOTgraphic[sin]",
"    \\stoptext",
" This will run gnuplot automatically and include the resulting figure in the document."
END_HELP(context)
#endif /* TERM_HELP */

